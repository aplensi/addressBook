# Qml

- AddWindow и ChangeWindow выглядят подозрительно одинаково. Можно вынести одинаковую часть в отдельный компонент, но еще лучше сделать одно окно и для создания, и для редактирования записей. Чтобы назначить разные действия на нажатие кнопки, можно для компонента сделать сигнал (типа accepted), а в main.qml создать 2 экземпляра окна одного типа, но сделать им разные действия в слоте onAccepted.
- Не использовать якоря (anchors) в компонентах, которые позиционируются через Layout. Эти способы конфликтуют.
- Лучше выровнять компоненты в окнах по центру, и задать им отступы от границ.

# Архитектура

- Класс Contoller. Если это имелся ввиду контроллер из MVC, то он не должен содержать данные, а должен только передавать вызовы от View к Model. Максимум заниматься валидацией и/или преобразованием данных. Предлагаю инициализацию движка qml вынести в main, а всю работу с данными вынести в PersonModel. В Controller можно оставить взаимодействие с БД и сделать валидацию. PersonService упразднить, этот функционал должен быть в модели.
- PersonService, Controller и PersonModel работают с QList\<Person\>. Это неудобно и нарушает инкапсуляцию. По идее, у тебя должно быть единое хранилище данных (PersonModel), которое содержит этот лист, а все остальные классы взаимодествуют с данными только посредством методов класса PersonModel.
- Не уверен насчет разделения на SetDatabase и GetDatabase. Если следовать принципу Interface Segregation, то надо тогда делать что-то типа IPesronsSource и IPersonsSink, и реализовывать их. А так мы ведь точно знаем, что у нас получение и запись данных в одной БД происходит.

# Разное

- qml файлы обычно смотрят через файл ресурсов. Добавлять их в DISTFILES не стоит, чтобы не захламлять дерево проекта.
- Каждый класс лучше держать в отдельном файле. Так легче ориентироваться. В Qt Creator есть удобный диалог для создания классов.
- Раскидать файлы в отдельные папки, чтобы легче было ориентироваться. Делят обычно в соответствии с архитектурой. Например, для MVC можно разложить на models, views, controllers, databases, etc...
- Почему QVariant::fromValue? Там же просто указатель на QObject надо передать.
```c++
    // controller.cpp
    engine.rootContext()->setContextProperty("person", QVariant::fromValue(&m_model));
```
- Метод PersonModel::get - интересная идея, но данные конкретной строчки можно вытащить из ListView. Писать преобразование в QVariantMap не очень вкусно.
- Метод PersonModel::updateList не нужен. Не стоит портить жизнь тем, кто будет работать с этой моделью необходимостью думать, когда надо вызвать этот метод. Эти сигналы можно просто вызвать в setPeople, а также в методах сортировки, когда они будут перенесены в модель.
- Кстати о people. Лучше когда для одной и той же сущности используется одно и тоже слово (Person -> Persons). People заставляет лишний раз думать. Persons - валидная форма в англ языке, я проверил:)
- Метод QList\<Person\> &PersonModel::getPersonList(). Плохо возвращать неконстантную ссылку. Кто угодно может изменить твои данные и нарушить логику работы с ними.
- В методах SetDatabase можно передавать объект Person, а не отдельные параметры. Так легче. А преобразовать параметры в объект можно в Controller.
- Метод SetDatabase::addPerson может возвращать id созданной записи. Тогда не нужен метод GetDatabase::getLastId. Обработку ошибки можно сделать передачей параметра по ссылке.
```c++
    // Тогда будет что-то типа
    void Controller::addButton(QString name, QString address, QString phone)
    {
        if(name == "" || address == "" || phone == "") return;
        
        Person person(0, name, address, phone);
        
        bool isOk = false;
        int id = m_setDb.addPerson(person, &isOk);
        
        if (!isOk) {
            qDebug() << "bla bla";
            return;
        }
        
        person.setId(id);
        
        m_model.addPerson(person);
    }
```
- Хранить ссылки на другие объекты лучше не по обычной ссылке &, а как умный указатель. У ссылки нельзя проверить, является ли она валидной.
